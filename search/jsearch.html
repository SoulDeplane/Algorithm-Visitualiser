<!DOCTYPE html>
<html>
<head>
<title>Algorithm Visualizer</title>
<link rel="icon" type="image/x-icon" href="C:/Users/Nitya/Desktop/Project/DAA/Website/icon1.jpeg">
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
body { margin: 0; }
div { padding: 5px; }
h1 { text-align: center; }
.one { background-image: url("C:/Users/Nitya/Desktop/Project/DAA/Website/background.jpeg"); color: white; }
.two { padding: 30px; }
th, td { padding: 5px; }
.sidenav {
  height: 100%;
  width: 0;
  position: fixed;
  z-index: 1;
  top: 0;
  left: 0;
  background-color: #111;
  overflow-x: hidden;
  transition: 0.5s;
  padding-top: 20px;
}
.sidenav a {
  padding: 15px 25px;
  text-decoration: none;
  font-size: 22px;
  color: #818181;
  display: block;
  transition: 0.3s;
}
.sidenav a:hover { color: #f1f1f1; }
.sidenav .closebtn {
  position: absolute;
  top: 10px;
  right: 20px;
  font-size: 36px;
  margin-left: 50px;
}
@media screen and (max-height: 450px) {
  .sidenav { padding-top: 15px; }
  .sidenav a { font-size: 18px; }
}
.tab-container {
  max-width: 400px;
  margin-left: 15px;
  border: 1px solid #ddd;
}
.tab-buttons {
  display: flex;
  background-color: #f1f1f1;
}
.tab-button {
  flex: 1;
  padding: 10px;
  border: none;
  cursor: pointer;
  background-color: inherit;
}
.tab-button.active { background-color: #ccc; }
.tab-content {
  padding: 10px;
  border-top: 1px solid #ddd;
}
.tab-pane { display: none; }
.tab-pane.active { display: block; }
</style>
</head>
<body>

<div id="mySidenav" class="sidenav">
  <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
  <a href="C:/Users/Nitya/Desktop/Project/DAA/Website/search/lsearch.html">Linear Search</a>
  <a href="C:/Users/Nitya/Desktop/Project/DAA/Website/search/bsearch.html">Binary Search</a>
  <a href="C:/Users/Nitya/Desktop/Project/DAA/Website/search/jsearch.html">Jump Search</a>
</div>

<div class="one">
<h1 align="CENTER" style="font-size:280%">Jump Search</h1>
</div>

<p align="CENTER" style="font-size:120%">
<span style="font-size:18px; cursor:pointer" onclick="openNav()">&#9776; </span>
<a href="C:/Users/Nitya/Desktop/Project/DAA/Website/home.html">Home | </a>
<a href="C:/Users/Nitya/Desktop/Project/DAA/Website/search.html">Searching Algorithms | </a>
<a href="C:/Users/Nitya/Desktop/Project/DAA/Website/sort.html">Sorting Algorithms | </a>
<a href="C:/Users/Nitya/Desktop/Project/DAA/Website/graph.html">Graph Algorithms | </a>
<a href="C:/Users/Nitya/Desktop/Project/DAA/Website/greedy.html">Greedy Algorithms | </a>
<a href="C:/Users/Nitya/Desktop/Project/DAA/Website/time.html"> Code Complexity Analyzer </a>
</p>
<hr>

<div class="two">
<h3><b> Description: </b></h3>
<p align="JUSTIFY">
Jump Search is an algorithm designed for sorted datasets. It functions by dividing the data into blocks (or intervals) of fixed size and "jumping" ahead by these intervals to locate the block that potentially contains the target element. Once the relevant block is identified, a linear search is performed within the block to find the target. The optimal jump size is approximately √n, where n is the size of the dataset.
</p>

<h3><b> Visual Representation: </b></h3>

<iframe src="jjsearch.html" width="410" height="275" style="border:1px solid #ccc; margin-left: 15px;"></iframe>

<h3><b> Code Implementation: </b></h3>
<div class="tab-container">
    <div class="tab-buttons">
        <button class="tab-button active" onclick="openTab(event, 'tab1')">C++</button>
        <button class="tab-button" onclick="openTab(event, 'tab2')">Python</button>
    </div>
    <div class="tab-content">
        <div id="tab1" class="tab-pane active">
            <pre><code>
#include&lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;

int jsearch(int arr[], int n, int x)
{
    	int step = sqrt(n);
    	int prev = 0;
    	while (arr[min(step, n)-1] < x)
	{
        	prev = step;
        	step += sqrt(n);
        	if (prev >= n) 
			return -1;
    	}
    	for (int i = prev; i < min(step, n); i++)
	{
        	if (arr[i] == x)
			return i;
    	}
    	return -1;
}

main()
{
    	int n, x;
    	cout << "Enter size of array: ";
    	cin >> n;
    	int arr[n];
    	cout << "Enter sorted elements: ";
    	for (int i = 0; i < n; i++)
		cin >> arr[i];
    	cout << "Enter key: ";
    	cin >> x;   
    	int index = jsearch(arr, n, x);
    	if (index != -1) 
		cout << "Element found at index " << index << endl;
    	else 
		cout << "Element not found" << endl;
    	return 0;
}
            </code></pre>
        </div>

        <div id="tab2" class="tab-pane">
            <pre><code>
import math

def jsearch(arr, x):
    	n = len(arr)
    	step = int(math.sqrt(n))
    	prev = 0
    	while arr[min(step, n)-1] < x:
        	prev = step
        	step += int(math.sqrt(n))
        	if prev >= n:
            		return -1
    	for i in range(prev, min(step, n)):
        	if arr[i] == x:
            		return i

    	return -1

arr=eval(input("Enter list: "))
x=int(input("Enter key: "))
i=jsearch(arr, x)
if i!=-1:
    	print("Element found at index", i)
else:
    	print("Element not found")
            </code></pre>
        </div>
    </div>
</div>

<h3><b> Time Complexity: </b></h3>
<p align="JUSTIFY">
<ul>
<li><b> Best Case:</b> Best Case: O[1] (if the target is the first element in the first block)   </li>
<li><b> Worst Case:</b>O[√n] (requires multiple jumps and a linear search within the block)  </li>
<li><b> Average Case:</b> O[√n] </li>
</ul>
</p>

<h3><b> Space Complexity: </b></h3>
<p align="JUSTIFY">
<ul>
<li> O[1] (in-place, no additional space required)   </li>

</ul>
</p>

<h3><b> Used for: </b></h3>
<p align="JUSTIFY">
<ul>
<li> Efficient searching in sorted datasets, particularly useful for datasets stored sequentially.
 </li>
</ul>
</p>

<h3><b> Applications: </b></h3>
<p align="JUSTIFY">
<ul>
<li>
<b> Efficient Searching in Sorted Data: </b>Optimal for large datasets where binary search may not be feasible, such as when data is stored sequentially.  
</li>
<li>
<b>Optimization Scenarios: </b>Often used when jumping through chunks of sorted data reduces the number of comparisons compared to linear search.  
</li>
<li>
<b>Educational Demonstrations: </b>A good example of combining linear search with block-based searching concepts for algorithm design.
</li>
</ul>
</p>

<script>
function openNav() {
  document.getElementById("mySidenav").style.width = "250px";
}

function closeNav() {
  document.getElementById("mySidenav").style.width = "0";
}

function openTab(evt, tabName) {
  document.querySelectorAll(".tab-pane").forEach(tab => tab.classList.remove("active"));
  document.querySelectorAll(".tab-button").forEach(btn => btn.classList.remove("active"));

  document.getElementById(tabName).classList.add("active");
  evt.currentTarget.classList.add("active");
}
</script>

</body>
</html>